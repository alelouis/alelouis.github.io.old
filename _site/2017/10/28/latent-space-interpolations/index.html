
<p>My intent with this post is to formalize thoughts I came accross while playing with generative models and especially VAEs. Firstly interested by visual aspects of latent space interpolation, I found myself digging deeper to gain high-dimensionnal intuitions and share here my understanding.</p>

<p>The toy we’ll be playing with is a simple VAE. I will start by making a brief summary of AE and VAE principles and then move to latent space interpolations (where beautiful things happen).</p>

<h2 id="auto-encoders">Auto-Encoders</h2>

<p>Auto-encoders are unsupervised neural networks architectures used to encode data into <strong>structured representations</strong>. While they can be used for dimensionality reduction (instead of PCA or t-SNE for example) various other applications are being explored (anomaly detection, generative models, exploratory analysis…).</p>

<p>Unlike typical supervised tasks, an auto-encoder learns an identity function between its inputs and outputs. While in the former a neural network typically learns a mapping between input samples and output labels, the latter is optimized to reconstruct the input the best it can.</p>

<p>This objective is not inherently useful : what is interesting here lies in the hidden layers, or more simply in this example the middle layer <script type="math/tex">\textbf{z}</script>. We call <script type="math/tex">\textbf{z}</script> the encoded or latent vector. The left part of the graph is the encoder part, it encodes the input into the latent space. The latent vector is then decoded by the decoder and outputs the input reconstruction. By setting the length of the middle vector <script type="math/tex">\textbf{z}</script> to a smaller value than the input dimension, the mapping has to find an efficient way to compress input samples into a smaller representations. The mapping (set of neural weights and biases) is learnt during training phase by minimizing the reconstruction error. The loss is often chosen between MSE and cross-entropy.</p>

<p><img src="../images/ae.svg" alt="dim" /></p>

<p><em>Usage example</em> : one wants to encode digits from their <em>28x28</em> 2D representation to a more compact representation, i.e a vector of length 2. During training phase, many samples are proposed to the network with the reconstruction error between the original image and the reconstructed output image being minimized. In the middle of the network is specified an hidden layer - the 2-dim vector <script type="math/tex">\textbf{z}</script> - so that all information <em>has</em> to be compressed into 2 values at some point. Obviously going from 784 dimensions to 2 is quite a drastic reduction, it forces the network to converge to efficient compression solutions. What we hope is that the low-dimensional representation is learning in an unsupervised way underlying concepts about the data (there are 10 digits, some orientation, thickness…) and encode each one of this concept into a dimension of the latent space.</p>

<p>It makes sense, but it can cheat.</p>

<p>Suppose the dimension of <script type="math/tex">\textbf{z}</script> is slightly higher. What mecanism can ensure that the learnt representation is not a dumb mapping between far apart regions of latent space and all input samples. Well nothing. For example the latent vector could easily encode each sample into binary positions and have very good reconstruction performance while having learn nothing about data structure.</p>

<p>Because the network finds its own ways to compress data, we can’t understand fully its representation by looking at it. Nothing ensures that the vector <script type="math/tex">\mathbf{z_1} = [2.2,1.3]</script> is decoded as an image of a 3 and <script type="math/tex">\mathbf{z_2} = [2.2,1.3]</script>, while very close in latent space, is <em>also</em> decoded as a 3. Any interpretation of what latent dimensions represent is here very difficult.</p>

<p>Moreover, its hard to generate samples from this type of network. To generate a sample you have to find a latent vector <script type="math/tex">\textbf{z}</script> that will produce, once decoded, a plausible output (in the sense similar to inputs on which the AE was trained). The manifold represented by all the latent vectors associated to input samples is probably not covering the entire <script type="math/tex">\textbf{z}</script> space and sampling randomly will probably lead you into dead zones.</p>

<p>These limitations, latent space interpretation and generation, are trying to be solved with VAEs.</p>

<h2 id="variational-auto-encoders">Variational Auto-Encoders</h2>

<p>I was lately interesed in VAEs or Variational Auto-Encoder. This name is actually a contraction of two fields not typically associated : variationnal inference and deep learning auto-encoders. Here is my attempt to explain VAEs as clearly as possible (a bit of math but nothing too complicated).</p>

<p>A VAE is an auto-encoder with stochastic components. The main motivation behind this design is to provide generative capabilities to the model by constraining the latent space shape.</p>

<p>It would be nice to be able to sample latent vectors from well known distributions and get from the decoding network plausible samples. VAEs precisely to that : in addition to regular AE behaviour i.e identity reconstruction, we constrain the latent space with a specified distribution, or prior (often noted as <script type="math/tex">P(z)</script>). The new loss function now has to penalize bad reconstruction performance (same as in AEs) and unconstrained latent representation. To make sure the latent representation is well contrained by our prior we can compute a distance between actual latent space distribution <script type="math/tex">Q(z\mid x)</script> and our chosen prior <script type="math/tex">P(z)</script> and minimize it.</p>

<p>An easy to sample from and simple prior we can use is the unit centered multivariate normal  <script type="math/tex">P(z) \sim \mathcal{N}(\textbf{0}, I)</script>.</p>

<p>KL-divergence is often used to compare two distribution. Our final loss can then be expressed as :</p>

<script type="math/tex; mode=display">\mathcal{L} =  -E_{z\sim Q(z\mid x)}[log(p(x\mid z))] + KL(Q(z\mid x)\mid \mid P(z))</script>

<p>We then take the assumption that the posterior is following a isotropic Gaussian distribution to simplify the KL divergence calculus (<script type="math/tex">\mathbf{z}</script> has dimension <script type="math/tex">D</script>):</p>

<script type="math/tex; mode=display">Q(\textbf{z}\mid x) \sim \mathcal{N}(\mu(x), \sigma^{2}(x) I)</script>

<script type="math/tex; mode=display">KL(Q(z\mid x)\mid \mid P(z)) = -\frac{1}{2}\sum_{d=1}^{D}(1+log(\sigma^{2}_d)-\mu^{2}_d-\sigma^{2}_d)</script>

<p>It also has the avantage to simplify our architecture : the encoder network only encodes two vectors for each sample : one of means and one of variances . The real latent vector is then sampled from the multivariate normal distribution. The training phase ensure that the posterior <script type="math/tex">Q(z\mid x)</script> doesn’t get too far from the prior <script type="math/tex">P(z)</script> while also giving good reconstruction performance.</p>

<p>I personnaly consider I don’t fully understand a concept if I can’t make it work in pratice. See a simple VAE implementation in PyTorch. <GIT LINK=""></GIT></p>

<p>By running the network on MNIST with a latent space of dimension 2 we can then explore latent space representation, a very visual part.</p>

<h3 id="latent-space">Latent space</h3>

<p>Latent variables are not observed variables that are describing the underlying properties of a process. For example, the vector <script type="math/tex">\theta</script> of a observed sequence of <script type="math/tex">x \sim \mathcal{N}(\theta, \sigma)</script> is a latent variable. We only get to see <script type="math/tex">x_i</script> while hidden <script type="math/tex">\theta</script> describe the underlying generating process from which observations are sampled.</p>

<p>The mean of a Gaussian distribution is not a very interesting latent variable (compared to what we <em>can</em> find). These days, variational auto-encoders are very popular. A large part of this hype is due to their ability to <em>infer</em> latent variables for a large scope of problems. Moreover, found latent variable are constrained to be relevant and we, <em>humans</em>, can sometimes interpret them.</p>

<p>We can use visual tools to explore latent space and understand what the model is doing.</p>

<h2 id="2d-latent-space-on-mnist-vae">2D Latent Space on MNIST VAE</h2>

<p>Humans are very limited because we can visualize things up to 3 dimensions naturaly. Let’s see what a 2-dimensional latent space looks like on a VAE trained on MNIST samples. As explained previously, we can generate latent vector by sampling from our prior <script type="math/tex">P(z) \sim \mathcal{N}(\textbf{0}, I)</script>. Sampling from this distribution will yield to random samples belonging to the 2D plane with many samples being generated near the mean <script type="math/tex">[0,0]</script>. If we want to explore the latent space smoothly we can ignore gaussian sampling and follow a continuous path on the 2D plane where our prior has high probability. The first idea we can get is to decode latent vectors belonging to a centered grid in latent space. In Python / PyTorch we could decode each grid point (latent vector) and display each output and the 2D plane.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
          <span class="n">z</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
          <span class="n">sample</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">P</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
          <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span><span class="mi">28</span><span class="p">)</span>
          <span class="n">final_img_grid</span><span class="p">[</span><span class="n">x_pixel</span><span class="p">:</span><span class="n">x_pixel</span><span class="o">+</span><span class="mi">28</span><span class="p">,</span> <span class="n">y_pixel</span><span class="p">:</span><span class="n">y_pixel</span><span class="o">+</span><span class="mi">28</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span>
          <span class="n">y_pixel</span> <span class="o">+=</span> <span class="mi">28</span>
      <span class="n">x_pixel</span> <span class="o">+=</span> <span class="mi">28</span>
<span class="n">y_pixel</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p><img src="../images/latent_space.png" alt="dim" /></p>

<p>Beautiful isn’t it ? The most fascinating thing is the smooth transitions between each of our human concepts (digits). Even if we have only two dimension, we can already see glimpses of the learned structure. The first dimension of <script type="math/tex">\mathbf{z}</script> encodes a bit the orientation attribute. See how negative value are tilted right, while positive values are tilted right. Obviously, 2 dimensions is very small, so the network has to encode other concepts in this dimension introducing correlated attributes.</p>

<p>The grid sampling is pretty but static, how is it like to move inside this space ?</p>

<p>We can set up a simple parametric curve describing a spiral inside the domain <script type="math/tex">x, y \in [-2,2]</script> and decode at regular interval (in parametric space) the latent vector to output the image. We visualize the curve overlayed on the gaussian prior, the latent vector at time t and the corresponding decoded image.</p>

<div style="text-align:center;">
<video style="margin: 0 auto; width: 100%; max-width: 1020px;" autoplay="" loop="loop">

```
   <source src="../images/animation.mp4" type="video/mp4" />
```

   </video>
</div>

<h3 id="what-about-higher-dimension-">What about higher dimension ?</h3>

<p>Going up in dimensions for <script type="math/tex">\mathbf{z}</script> is fairly easy in code, but we have to be careful when exploring high-dimensional spaces. After seeing the 2D grid, it’s easy to think about a 3D box. Now think about a 100D box. Hard right ? Not only it’s impossible for us to have a visual representation of such objects, but our intuition in low dimensional spaces are just wrong as we go up in dimensions.</p>

<p>Let’s think about a simple object : all its points are at the same distance of another center point. In 2D it’s called a circle, in 2D a sphere … Now let’s compute a basic property of this object :</p>

<p>Area of the unit-circle : <script type="math/tex">V_2 = \pi</script></p>

<p>3D : Volume of unit-sphere : <script type="math/tex">V_3 = \frac{4}{3}\pi​</script></p>

<p>4D : Volume of unit 4-sphere : <script type="math/tex">V_4 = \frac{1}{2}\pi^{2}</script></p>

<p>The volume seems to increase, nothing strange.</p>

<p>General expression : <script type="math/tex">V_n={\pi^{n/2}\over \Gamma(n/2+1)}</script></p>

<p><img src="../images/sphere.svg" alt="dim" /></p>

<p>Oops. This is something our intuition has struggles dealing with. How does it have consequences in high-dimensionnal space exploration ? Well because the volume of hyperspheres goes to 0 as dimensions increase, gaussian sampling is a bit <em>different</em>. While a multivariate normal still has its maximum at the origin, if we were to compute the probability that samples belong to a n-sphere centered at origin we would integrate the density on the hypersphere volume, as to say 0. Hmm. This mean we have a very low probability of having samples close to origin (which is not the case in low-dimension). More precisely, as we have to increase the radius of the n-sphere for it to have a sufficient volume and therefore a bit of gaussian integrated density, there is a gap where almost no sample are sampled. All sampling is concentrated within a slice a the space. We can see it in action by plotting the norm of sampled vector for multivariate normal of various dimensions :</p>

<p><img src="../images/dim.svg" alt="dim" /></p>

